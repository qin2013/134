<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ«æ—¥æ±‚ç”Ÿï¼šæ˜Ÿçƒæ¸¸æˆ</title>
    <style>
        :root {
            --danger-color: #c33;
            --warning-color: #cc3;
            --safe-color: #3c3;
            --primary-color: #55f;
            --star-color: #ff0;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #111;
            color: #eee;
            max-width: 600px;
            margin: 0 auto;
            padding: 10px;
            touch-action: manipulation;
            background-image: radial-gradient(#222 1px, transparent 1px);
            background-size: 15px 15px;
        }
        
        .container {
            display: grid;
            grid-template-areas:
                "header header"
                "stats stats"
                "main main"
                "map actions"
                "inventory inventory"
                "log log";
            gap: 10px;
        }
        
        .header {
            grid-area: header;
            text-align: center;
            border-bottom: 2px solid var(--star-color);
            padding-bottom: 5px;
            position: relative;
        }
        
        .weather-icon {
            position: absolute;
            right: 10px;
            top: 10px;
            font-size: 24px;
        }
        
        .stats {
            grid-area: stats;
            display: grid;
            grid-template-columns: 1fr 1fr;
            background-color: #222;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        
        .stat {
            margin: 5px;
        }
        
        .stat-name {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        
        .stat-value {
            font-weight: bold;
        }
        
        .health { color: var(--danger-color); }
        .hunger { color: var(--warning-color); }
        .energy { color: var(--safe-color); }
        .infection { color: #c3c; }
        .temperature { color: #3cf; }
        .san { color: #99f; }
        
        .progress-bar {
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            margin-top: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            border-radius: 4px;
        }
        
        .main-area {
            grid-area: main;
            background-color: #222;
            padding: 15px;
            border-radius: 5px;
            min-height: 100px;
            border: 1px solid #333;
            position: relative;
        }
        
        .location-tag {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #333;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .action-buttons {
            grid-area: actions;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .map-container {
            grid-area: map;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        
        .map-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
        }
        
        .map-tile {
            aspect-ratio: 1;
            background-color: #333;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .map-tile:active {
            transform: scale(0.95);
        }
        
        .map-tile.current {
            box-shadow: 0 0 0 2px var(--star-color);
        }
        
        .map-tile.discovered {
            background-color: #444;
        }
        
        .map-tile.undiscovered {
            background-color: #222;
            color: #666;
        }
        
        .btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            border: 1px solid #444;
        }
        
        .btn:active {
            transform: scale(0.95);
            background-color: var(--primary-color);
        }
        
        .btn-primary {
            background-color: var(--primary-color);
        }
        
        .btn-star {
            background-color: var(--star-color);
            color: #333;
        }
        
        .btn-danger {
            background-color: var(--danger-color);
        }
        
        .btn-warning {
            background-color: var(--warning-color);
            color: #333;
        }
        
        .btn-disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .inventory {
            grid-area: inventory;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }
        
        .item {
            background-color: #333;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #444;
            font-size: 13px;
            text-align: center;
        }
        
        .item-count {
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .event-log {
            grid-area: log;
            height: 150px;
            overflow-y: auto;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 13px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
            line-height: 1.4;
        }
        
        .log-entry.warning {
            color: var(--warning-color);
        }
        
        .log-entry.danger {
            color: var(--danger-color);
            font-weight: bold;
        }
        
        .log-entry.positive {
            color: var(--safe-color);
        }
        
        .log-entry.info {
            color: #99f;
        }
        
        .log-entry.star {
            color: var(--star-color);
            text-shadow: 0 0 5px var(--star-color);
        }
        
        /* æ ‡ç­¾é¡µæ ·å¼ */
        .tabs {
            display: flex;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        
        .tab {
            padding: 5px 10px;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 3px 3px 0 0;
        }
        
        .tab.active {
            background-color: #333;
            border: 1px solid #444;
            border-bottom: none;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* æŠ€èƒ½æ ‘æ ·å¼ */
        .skill-tree {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .skill {
            background-color: #333;
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            border: 1px solid #444;
            cursor: pointer;
        }
        
        .skill.learned {
            border-color: var(--safe-color);
            background-color: #334;
        }
        
        .skill.available {
            border-color: var(--star-color);
        }
        
        .skill.unavailable {
            opacity: 0.5;
        }
        
        /* åŸºåœ°å»ºè®¾æ ·å¼ */
        .facilities {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .facility {
            background-color: #333;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            border: 1px solid #444;
        }
        
        .facility-level {
            color: var(--warning-color);
            font-weight: bold;
        }
        
        /* åˆ¶ä½œé¢æ¿æ ·å¼ */
        .recipes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .recipe {
            background-color: #333;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            border: 1px solid #444;
        }
        
        .recipe-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .recipe-materials {
            font-size: 11px;
            color: #999;
            margin-bottom: 5px;
        }
        
        /* çŠ¶æ€æ•ˆæœæ ·å¼ */
        .status-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .status-effect {
            background-color: #333;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 11px;
            border: 1px solid #444;
        }
        
        .effect-buff {
            border-color: var(--safe-color);
        }
        
        .effect-debuff {
            border-color: var(--danger-color);
        }
        
        .effect-star {
            border-color: var(--star-color);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0.4); }
            70% { box-shadow: 0 0 0 5px rgba(255, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 0, 0); }
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 500px) {
            .container {
                grid-template-areas:
                    "header"
                    "stats"
                    "main"
                    "map"
                    "actions"
                    "inventory"
                    "log";
            }
            
            .action-buttons {
                grid-template-columns: 1fr;
            }
        }
        
        /* æ˜Ÿçƒç‰¹æ•ˆ */
        .star-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: var(--star-color);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            animation: twinkle 1s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.2; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>æœ«æ—¥æ±‚ç”Ÿï¼šæ˜Ÿçƒæ¸¸æˆ</h1>
            <div>ç¬¬ <span id="day">1</span> å¤© <span id="time">æ—©æ™¨</span> <span id="weather">â˜€ï¸</span></div>
            <div class="weather-icon" id="temperature">ğŸŒ¡ï¸ 22Â°C</div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-name">
                    <span>â¤ï¸ ç”Ÿå‘½å€¼</span>
                    <span class="stat-value health" id="health">100/100</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill health" id="health-bar"></div>
                </div>
            </div>
            <div class="stat">
                <div class="stat-name">
                    <span>ğŸ– é¥¥é¥¿åº¦</span>
                    <span class="stat-value hunger" id="hunger">80/100</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill hunger" id="hunger-bar"></div>
                </div>
            </div>
            <div class="stat">
                <div class="stat-name">
                    <span>âš¡ ç²¾åŠ›</span>
                    <span class="stat-value energy" id="energy">100/100</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill energy" id="energy-bar"></div>
                </div>
            </div>
            <div class="stat">
                <div class="stat-name">
                    <span>â˜£ï¸ æ„ŸæŸ“åº¦</span>
                    <span class="stat-value infection" id="infection">0/100</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill infection" id="infection-bar"></div>
                </div>
            </div>
            <div class="stat">
                <div class="stat-name">
                    <span>ğŸ§  SANå€¼</span>
                    <span class="stat-value san" id="san">80/100</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill san" id="san-bar"></div>
                </div>
            </div>
            <div class="stat">
                <div class="stat-name">
                    <span>ğŸ›¡ï¸ é˜²å¾¡</span>
                    <span class="stat-value" id="defense">5</span>
                </div>
            </div>
        </div>
        
        <div class="main-area">
            <div class="location-tag" id="location-tag">é¿éš¾æ‰€</div>
            <div id="location-description">ä½ åœ¨ä¸€é—´ç ´æ—§çš„é¿éš¾æ‰€ä¸­é†’æ¥ï¼Œçª—å¤–ä¼ æ¥ä½æ²‰çš„å˜¶å¼å£°...å¤©ç©ºä¸­é—ªçƒç€ä¸å¯»å¸¸çš„æ˜Ÿå…‰ã€‚</div>
            <div id="event-display"></div>
            
            <div class="status-effects" id="status-effects">
                <div class="status-effect effect-buff">åº‡æŠ¤æ‰€ +5é˜²å¾¡</div>
            </div>
        </div>
        
        <div class="map-container">
            <h3>åŒºåŸŸåœ°å›¾</h3>
            <div class="map-grid" id="map-grid">
                <!-- åœ°å›¾æ ¼å­å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>
        
        <div class="action-buttons">
            <button class="btn" id="btn-explore">ğŸ” æ¢ç´¢</button>
            <button class="btn" id="btn-scavenge">ğŸ§º æœåˆ®</button>
            <button class="btn" id="btn-rest">ğŸ’¤ ä¼‘æ¯</button>
            <button class="btn" id="btn-eat">ğŸ½ï¸ è¿›é£Ÿ</button>
            <button class="btn btn-danger" id="btn-fight">âš”ï¸ æˆ˜æ–—</button>
            <button class="btn" id="btn-craft">ğŸ› ï¸ åˆ¶ä½œ</button>
            <button class="btn" id="btn-build">ğŸ—ï¸ å»ºé€ </button>
            <button class="btn" id="btn-skills">ğŸ“š æŠ€èƒ½</button>
            <button class="btn btn-star" id="btn-next">â­ï¸ ä¸‹ä¸€æ—¶æ®µ</button>
            <button class="btn" id="btn-treat">ğŸ’‰ æ²»ç–—</button>
            <button class="btn" id="btn-save">ğŸ’¾ ä¿å­˜</button>
            <button class="btn" id="btn-load">ğŸ”ƒ åŠ è½½</button>
        </div>
        
        <div class="inventory">
            <div class="tabs">
                <div class="tab active" data-tab="items">ç‰©å“</div>
                <div class="tab" data-tab="weapons">æ­¦å™¨</div>
                <div class="tab" data-tab="armor">æŠ¤ç”²</div>
                <div class="tab" data-tab="resources">èµ„æº</div>
            </div>
            
            <div class="tab-content active" id="tab-items">
                <div class="inventory-grid" id="inventory-items">
                    <!-- ç‰©å“å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <div class="tab-content" id="tab-weapons">
                <div class="inventory-grid" id="inventory-weapons">
                    <!-- æ­¦å™¨å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <div class="tab-content" id="tab-armor">
                <div class="inventory-grid" id="inventory-armor">
                    <!-- æŠ¤ç”²å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
            
            <div class="tab-content" id="tab-resources">
                <div class="inventory-grid" id="inventory-resources">
                    <!-- èµ„æºå°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
        
        <div class="event-log">
            <h3>äº‹ä»¶æ—¥å¿—</h3>
            <div id="log-entries">
                <div class="log-entry">[æ—©æ™¨] ä½ ä»ä¸å®‰çš„ç¡çœ ä¸­é†’æ¥</div>
                <div class="log-entry star">[æ—©æ™¨] å¤©ç©ºä¸­é—ªçƒç€ä¸å¯»å¸¸çš„æ˜Ÿå…‰...</div>
            </div>
        </div>
    </div>

    <!-- æ¨¡æ€æ¡† -->
    <div id="craft-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 100; padding: 20px; box-sizing: border-box; overflow-y: auto;">
        <div style="background-color: #222; max-width: 500px; margin: 20px auto; padding: 20px; border-radius: 5px; border: 1px solid #333;">
            <h2 style="margin-top: 0;">åˆ¶ä½œç‰©å“</h2>
            <div id="craft-recipes" style="display: grid; gap: 10px;">
                <!-- é…æ–¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button id="btn-close-craft" style="margin-top: 20px; padding: 10px 20px; background-color: var(--danger-color); color: white; border: none; border-radius: 5px; cursor: pointer;">å…³é—­</button>
        </div>
    </div>

    <div id="build-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 100; padding: 20px; box-sizing: border-box; overflow-y: auto;">
        <div style="background-color: #222; max-width: 500px; margin: 20px auto; padding: 20px; border-radius: 5px; border: 1px solid #333;">
            <h2 style="margin-top: 0;">å»ºé€ è®¾æ–½</h2>
            <div id="build-options" style="display: grid; gap: 10px;">
                <!-- å»ºé€ é€‰é¡¹å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button id="btn-close-build" style="margin-top: 20px; padding: 10px 20px; background-color: var(--danger-color); color: white; border: none; border-radius: 5px; cursor: pointer;">å…³é—­</button>
        </div>
    </div>

    <div id="skills-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 100; padding: 20px; box-sizing: border-box; overflow-y: auto;">
        <div style="background-color: #222; max-width: 500px; margin: 20px auto; padding: 20px; border-radius: 5px; border: 1px solid #333;">
            <h2 style="margin-top: 0;">æŠ€èƒ½æ ‘</h2>
            <div style="margin-bottom: 15px;">
                <span>æŠ€èƒ½ç‚¹: </span>
                <span id="skill-points" style="font-weight: bold; color: var(--star-color);">0</span>
            </div>
            <div id="skill-trees" style="display: grid; gap: 20px;">
                <!-- æŠ€èƒ½æ ‘å°†ç”±JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button id="btn-close-skills" style="margin-top: 20px; padding: 10px 20px; background-color: var(--danger-color); color: white; border: none; border-radius: 5px; cursor: pointer;">å…³é—­</button>
        </div>
    </div>

    <div id="load-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 100; padding: 20px; box-sizing: border-box; overflow-y: auto;">
        <div style="background-color: #222; max-width: 500px; margin: 20px auto; padding: 20px; border-radius: 5px; border: 1px solid #333;">
            <h2 style="margin-top: 0;">åŠ è½½å­˜æ¡£</h2>
            <div id="save-slots" style="display: grid; gap: 10px;">
                <button class="btn" onclick="loadGame(1)">å­˜æ¡£ 1</button>
                <button class="btn" onclick="loadGame(2)">å­˜æ¡£ 2</button>
                <button class="btn" onclick="loadGame(3)">å­˜æ¡£ 3</button>
            </div>
            <button id="btn-close-load" style="margin-top: 20px; padding: 10px 20px; background-color: var(--danger-color); color: white; border: none; border-radius: 5px; cursor: pointer;">å…³é—­</button>
        </div>
    </div>

    <script>
        // ======================
        // æ¸¸æˆçŠ¶æ€å’Œæ•°æ®
        // ======================
        const gameState = {
            version: "1.1",
            day: 1,
            time: 0, // 0-æ—©æ™¨, 1-ä¸­åˆ, 2-å‚æ™š, 3-å¤œæ™š
            times: ["æ—©æ™¨", "ä¸­åˆ", "å‚æ™š", "å¤œæ™š"],
            health: 100,
            maxHealth: 100,
            hunger: 80,
            maxHunger: 100,
            energy: 100,
            maxEnergy: 100,
            infection: 0,
            maxInfection: 100,
            san: 80,
            maxSan: 100,
            defense: 5,
            skillPoints: 0,
            temperature: 22,
            weather: "æ™´å¤©",
            weathers: ["æ™´å¤©", "é›¨å¤©", "é›¾å¤©", "æš´é£é›¨", "æå¯’", "æ˜Ÿå¤œ"],
            weatherIcons: ["â˜€ï¸", "ğŸŒ§ï¸", "ğŸŒ«ï¸", "â›ˆï¸", "â„ï¸", "âœ¨"],
            location: "é¿éš¾æ‰€",
            locations: {
                "é¿éš¾æ‰€": { description: "ä½ çš„ä¸´æ—¶åº‡æŠ¤æ‰€ï¼Œç›¸å¯¹å®‰å…¨", danger: 1, resources: [] },
                "åºŸå¼ƒè¶…å¸‚": { description: "è´§æ¶ä¸Šå¯èƒ½è¿˜æœ‰å‰©ä½™çš„é£Ÿç‰©", danger: 3, resources: ["é£Ÿç‰©", "æ—¥ç”¨å“"] },
                "åŠ æ²¹ç«™": { description: "å¯èƒ½æœ‰ç‡ƒæ–™å’Œå·¥å…·", danger: 4, resources: ["ç‡ƒæ–™", "å·¥å…·"] },
                "åŒ»é™¢": { description: "åŒ»ç–—ç‰©èµ„ä¸°å¯Œä½†æå…¶å±é™©", danger: 5, resources: ["åŒ»ç–—"] },
                "è­¦å¯Ÿå±€": { description: "æ­¦å™¨å’Œé˜²å…·çš„æ¥æº", danger: 4, resources: ["æ­¦å™¨"] },
                "å±…æ°‘åŒº": { description: "æ™®é€šä½å®…ï¼Œå¯èƒ½æœ‰åŸºæœ¬ç‰©èµ„", danger: 2, resources: ["é£Ÿç‰©", "æ—¥ç”¨å“"] },
                "å­¦æ ¡": { description: "å¯èƒ½æœ‰ä¹¦ç±å’Œç®€å•å·¥å…·", danger: 3, resources: ["çŸ¥è¯†"] },
                "å»ºç­‘å·¥åœ°": { description: "å»ºç­‘ææ–™ä¸°å¯Œ", danger: 3, resources: ["å»ºæ"] },
                "å†›äº‹å“¨æ‰€": { description: "é«˜çº§æ­¦å™¨ä½†å±é™©æé«˜", danger: 6, resources: ["æ­¦å™¨", "å¼¹è¯"] },
                "å¤©æ–‡å°": { description: "ç ”ç©¶æ˜Ÿç©ºçš„åœ°æ–¹ï¼Œå¯èƒ½æ‰¾åˆ°ç‰¹æ®Šç‰©å“", danger: 4, resources: ["æ˜Ÿå°˜"] }
            },
            currentPosition: { x: 2, y: 2 }, // åœ°å›¾ä¸­å¿ƒä½ç½®
            discoveredLocations: ["é¿éš¾æ‰€"],
            map: Array(5).fill().map(() => Array(5).fill(null)),
            inventory: {
                // æ¶ˆè€—å“
                "ç½å¤´": { type: "food", count: 3, effect: { hunger: 30 } },
                "ç“¶è£…æ°´": { type: "food", count: 2, effect: { hunger: 10 } },
                "ç»·å¸¦": { type: "medical", count: 2, effect: { health: 20 } },
                "æŠ—ç”Ÿç´ ": { type: "medical", count: 1, effect: { infection: -30 } },
                "é•‡é™å‰‚": { type: "medical", count: 0, effect: { san: 20 } },
                
                // æ­¦å™¨
                "å°åˆ€": { type: "weapon", count: 1, damage: 10, durability: 50 },
                "æ£’çƒæ£": { type: "weapon", count: 0, damage: 15, durability: 30 },
                "æ‰‹æª": { type: "weapon", count: 0, damage: 25, ammo: 0, maxAmmo: 12, durability: 100 },
                
                // æŠ¤ç”²
                "çš®å¤¹å…‹": { type: "armor", count: 0, defense: 3, durability: 40 },
                "è­¦ç”¨é˜²å¼¹è¡£": { type: "armor", count: 0, defense: 8, durability: 60 },
                
                // èµ„æº
                "æœ¨æ": { type: "resource", count: 5 },
                "é‡‘å±": { type: "resource", count: 2 },
                "å¸ƒæ–™": { type: "resource", count: 3 },
                "ç”µå­é›¶ä»¶": { type: "resource", count: 0 },
                "å¼¹è¯": { type: "resource", count: 0 },
                "ç‡ƒæ–™": { type: "resource", count: 0 },
                "æ˜Ÿå°˜": { type: "resource", count: 0 }
            },
            equippedWeapon: null,
            equippedArmor: null,
            statusEffects: [
                { name: "åº‡æŠ¤æ‰€", type: "buff", description: "åŸºç¡€é˜²å¾¡+5", duration: Infinity }
            ],
            facilities: {
                "å·¥ä½œå°": { level: 1, maxLevel: 3, description: "è§£é”æ›´å¤šåˆ¶ä½œé…æ–¹", requirements: { "æœ¨æ": 10, "é‡‘å±": 5 } },
                "é›¨æ°´æ”¶é›†å™¨": { level: 0, maxLevel: 2, description: "æ¯å¤©æä¾›å‡€æ°´", requirements: { "æœ¨æ": 5, "å¸ƒæ–™": 3 } },
                "èœå›­": { level: 0, maxLevel: 3, description: "æ¯å¤©æä¾›é£Ÿç‰©", requirements: { "æœ¨æ": 8 } },
                "é˜²å¾¡å·¥äº‹": { level: 0, maxLevel: 3, description: "å‡å°‘è¢«è¢­å‡»å‡ ç‡", requirements: { "æœ¨æ": 15, "é‡‘å±": 10 } },
                "åŒ»ç–—ç«™": { level: 0, maxLevel: 2, description: "ç¼“æ…¢æ¢å¤å¥åº·", requirements: { "ç”µå­é›¶ä»¶": 2, "å¸ƒæ–™": 5 } },
                "æ˜Ÿå°˜æ”¶é›†å™¨": { level: 0, maxLevel: 1, description: "æ”¶é›†æ˜Ÿå°˜ç”¨äºç‰¹æ®Šåˆ¶ä½œ", requirements: { "ç”µå­é›¶ä»¶": 5, "é‡‘å±": 10 } }
            },
            recipes: {
                "ç®€æ˜“ç»·å¸¦": { type: "medical", materials: { "å¸ƒæ–™": 2 }, result: { "ç»·å¸¦": 1 } },
                "æœ¨åˆ¶é•¿çŸ›": { type: "weapon", materials: { "æœ¨æ": 3 }, result: { "æœ¨åˆ¶é•¿çŸ›": 1 }, requires: { "å·¥ä½œå°": 1 } },
                "ç®€æ˜“é™·é˜±": { type: "tool", materials: { "æœ¨æ": 2, "é‡‘å±": 1 }, result: { "ç®€æ˜“é™·é˜±": 1 }, requires: { "å·¥ä½œå°": 1 } },
                "å­å¼¹": { type: "ammo", materials: { "é‡‘å±": 1 }, result: { "å¼¹è¯": 5 }, requires: { "å·¥ä½œå°": 2 } },
                "é“åˆ¶æŠ¤ç”²": { type: "armor", materials: { "é‡‘å±": 5, "å¸ƒæ–™": 3 }, result: { "é“åˆ¶æŠ¤ç”²": 1 }, requires: { "å·¥ä½œå°": 2 } },
                "æ˜Ÿå…‰æŠ¤ç¬¦": { type: "trinket", materials: { "æ˜Ÿå°˜": 3, "é‡‘å±": 2 }, result: { "æ˜Ÿå…‰æŠ¤ç¬¦": 1 }, requires: { "æ˜Ÿå°˜æ”¶é›†å™¨": 1 }, 
                    effect: { san: 10, description: "ç¼“æ…¢æ¢å¤SANå€¼" } }
            },
            skills: {
                "ç”Ÿå­˜ä¸“å®¶": { 
                    description: "å‡å°‘20%é£Ÿç‰©å’Œæ°´æ¶ˆè€—", 
                    cost: 1, 
                    learned: false, 
                    requirements: [], 
                    effect: () => { gameState.foodConsumptionRate = 0.8; } 
                },
                "ç†Ÿç»ƒæˆ˜å£«": { 
                    description: "è¿‘æˆ˜ä¼¤å®³+30%", 
                    cost: 1, 
                    learned: false, 
                    requirements: [], 
                    effect: () => { gameState.meleeDamageBonus = 1.3; } 
                },
                "ç¥å°„æ‰‹": { 
                    description: "è¿œç¨‹æ­¦å™¨ä¼¤å®³+25%", 
                    cost: 1, 
                    learned: false, 
                    requirements: [], 
                    effect: () => { gameState.rangedDamageBonus = 1.25; } 
                },
                "åŒ»ç–—çŸ¥è¯†": { 
                    description: "æ²»ç–—æ•ˆæœ+40%", 
                    cost: 1, 
                    learned: false, 
                    requirements: [], 
                    effect: () => { gameState.healingBonus = 1.4; } 
                },
                "å·¥ç¨‹å¸ˆ": { 
                    description: "è§£é”é«˜çº§åˆ¶ä½œé…æ–¹", 
                    cost: 2, 
                    learned: false, 
                    requirements: [], 
                    effect: () => { gameState.engineerUnlocked = true; } 
                },
                "é’¢ç­‹é“éª¨": { 
                    description: "æœ€å¤§ç”Ÿå‘½å€¼+20", 
                    cost: 2, 
                    learned: false, 
                    requirements: ["ç†Ÿç»ƒæˆ˜å£«"], 
                    effect: () => { gameState.maxHealth += 20; gameState.health += 20; } 
                },
                "æ˜Ÿå°˜å­¦è€…": {
                    description: "è§£é”æ˜Ÿå°˜ç§‘æŠ€å’Œé…æ–¹",
                    cost: 3,
                    learned: false,
                    requirements: ["å·¥ç¨‹å¸ˆ"],
                    effect: () => { gameState.starKnowledge = true; }
                }
            },
            events: [],
            lastAttackDay: 0,
            zombieHordeSize: 0,
            foodConsumptionRate: 1.0,
            meleeDamageBonus: 1.0,
            rangedDamageBonus: 1.0,
            healingBonus: 1.0,
            engineerUnlocked: false,
            starKnowledge: false
        };

        // ç¼“å­˜DOMå…ƒç´ 
        const elements = {
            day: document.getElementById("day"),
            time: document.getElementById("time"),
            weather: document.getElementById("weather"),
            temperature: document.getElementById("temperature"),
            "location-tag": document.getElementById("location-tag"),
            "location-description": document.getElementById("location-description"),
            health: document.getElementById("health"),
            hunger: document.getElementById("hunger"),
            energy: document.getElementById("energy"),
            infection: document.getElementById("infection"),
            san: document.getElementById("san"),
            defense: document.getElementById("defense"),
            "health-bar": document.getElementById("health-bar"),
            "hunger-bar": document.getElementById("hunger-bar"),
            "energy-bar": document.getElementById("energy-bar"),
            "infection-bar": document.getElementById("infection-bar"),
            "san-bar": document.getElementById("san-bar"),
            "log-entries": document.getElementById("log-entries"),
            "map-grid": document.getElementById("map-grid"),
            "inventory-items": document.getElementById("inventory-items"),
            "inventory-weapons": document.getElementById("inventory-weapons"),
            "inventory-armor": document.getElementById("inventory-armor"),
            "inventory-resources": document.getElementById("inventory-resources"),
            "status-effects": document.getElementById("status-effects")
        };

        // åˆå§‹åŒ–åœ°å›¾
        function initializeMap() {
            const locationNames = Object.keys(gameState.locations).filter(name => name !== "é¿éš¾æ‰€");
            
            // ç¡®ä¿é¿éš¾æ‰€åœ¨ä¸­å¿ƒ
            gameState.map[2][2] = "é¿éš¾æ‰€";
            
            // éšæœºæ”¾ç½®å…¶ä»–åœ°ç‚¹
            const positions = [];
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    if (x !== 2 || y !== 2) {
                        positions.push({ x, y });
                    }
                }
            }
            
            // éšæœºæ‰“ä¹±ä½ç½®
            positions.sort(() => Math.random() - 0.5);
            
            // æ”¾ç½®åœ°ç‚¹
            for (let i = 0; i < Math.min(locationNames.length, positions.length); i++) {
                const pos = positions[i];
                gameState.map[pos.y][pos.x] = locationNames[i];
            }
        }

        // ======================
        // æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½
        // ======================
        function nextTime() {
            gameState.time = (gameState.time + 1) % 4;
            if (gameState.time === 0) {
                gameState.day++;
                
                // æ¯å¤©å¼€å§‹æ—¶è·å¾—æŠ€èƒ½ç‚¹
                if (gameState.day % 3 === 0) {
                    gameState.skillPoints++;
                    addLog("è·å¾—1ç‚¹æŠ€èƒ½ç‚¹", "positive");
                }
                
                // éšæœºå¤©æ°”å˜åŒ–
                changeWeather();
                
                // æ¯æ—¥çŠ¶æ€æ›´æ–°
                dailyUpdate();
            }
            
            updateTimeEffects();
            processStatusEffects();
            triggerRandomEvent();
            updateUI();
            
            // æ˜Ÿå¤œç‰¹æ•ˆ
            if (gameState.weather === "æ˜Ÿå¤œ") {
                createStarParticles();
            }
        }

        function changeWeather() {
            // æ˜Ÿå¤œæ˜¯ç¨€æœ‰å¤©æ°”
            const weatherPool = [...gameState.weathers];
            if (Math.random() < 0.9) { // 90%å‡ ç‡ä¸å‡ºç°æ˜Ÿå¤œ
                weatherPool.pop();
            }
            
            const weatherIndex = Math.floor(Math.random() * weatherPool.length);
            gameState.weather = weatherPool[weatherIndex];
            
            // å¤©æ°”æ•ˆæœ
            switch (gameState.weather) {
                case "é›¨å¤©":
                    gameState.temperature = 15 + Math.floor(Math.random() * 5);
                    addLog("å¼€å§‹ä¸‹é›¨äº†ï¼Œæ¸©åº¦ä¸‹é™", "info");
                    break;
                case "é›¾å¤©":
                    gameState.temperature = 18 + Math.floor(Math.random() * 5);
                    addLog("æµ“é›¾ç¬¼ç½©ï¼Œèƒ½è§åº¦é™ä½", "warning");
                    break;
                case "æš´é£é›¨":
                    gameState.temperature = 12 + Math.floor(Math.random() * 5);
                    addLog("æš´é£é›¨æ¥è¢­ï¼Œå¤–å‡ºæ›´åŠ å±é™©", "danger");
                    break;
                case "æå¯’":
                    gameState.temperature = -10 + Math.floor(Math.random() * 5);
                    addLog("æå¯’å¤©æ°”ï¼Œæ³¨æ„ä¿æš–", "danger");
                    break;
                case "æ˜Ÿå¤œ":
                    gameState.temperature = 10 + Math.floor(Math.random() * 10);
                    addLog("å¤œç©ºé—ªçƒç€ç¥ç§˜çš„æ˜Ÿå…‰...", "star");
                    break;
                default: // æ™´å¤©
                    gameState.temperature = 22 + Math.floor(Math.random() * 10);
            }
        }

        function dailyUpdate() {
            // é¥¥é¥¿å’Œå£æ¸´
            const hungerLoss = Math.floor(15 * gameState.foodConsumptionRate);
            gameState.hunger = Math.max(0, gameState.hunger - hungerLoss);
            
            if (gameState.hunger <= 0) {
                gameState.health = Math.max(0, gameState.health - 10);
                addLog("é¥¥é¥¿ä½¿ä½ å˜å¾—è™šå¼±", "danger");
            }
            
            // æ„ŸæŸ“è¿›å±•
            if (gameState.infection > 0) {
                gameState.infection = Math.min(100, gameState.infection + 5);
                if (gameState.infection >= 100) {
                    gameState.health = 0;
                    addLog("æ„ŸæŸ“å·²ç»æ‰©æ•£åˆ°å…¨èº«...æ¸¸æˆç»“æŸ", "danger");
                } else if (gameState.infection >= 70) {
                    gameState.health = Math.max(0, gameState.health - 5);
                    addLog("æ„ŸæŸ“æ­£åœ¨æ¶åŒ–ï¼Œä½ æ„Ÿåˆ°éå¸¸ä¸é€‚", "danger");
                }
            }
            
            // SANå€¼æ¢å¤
            if (gameState.location === "é¿éš¾æ‰€") {
                gameState.san = Math.min(gameState.maxSan, gameState.san + 5);
            }
            
            // è®¾æ–½æ•ˆæœ
            if (gameState.facilities["é›¨æ°´æ”¶é›†å™¨"].level > 0) {
                addItem("ç“¶è£…æ°´", gameState.facilities["é›¨æ°´æ”¶é›†å™¨"].level);
                addLog(`é›¨æ°´æ”¶é›†å™¨æä¾›äº†${gameState.facilities["é›¨æ°´æ”¶é›†å™¨"].level}ç“¶æ°´`, "positive");
            }
            
            if (gameState.facilities["èœå›­"].level > 0) {
                addItem("ç½å¤´", gameState.facilities["èœå›­"].level);
                addLog(`èœå›­æ”¶è·äº†${gameState.facilities["èœå›­"].level}ä¸ªç½å¤´`, "positive");
            }
            
            if (gameState.facilities["åŒ»ç–—ç«™"].level > 0) {
                gameState.health = Math.min(gameState.maxHealth, gameState.health + (5 * gameState.facilities["åŒ»ç–—ç«™"].level));
                if (gameState.infection > 0) {
                    gameState.infection = Math.max(0, gameState.infection - (2 * gameState.facilities["åŒ»ç–—ç«™"].level));
                }
                addLog(`åŒ»ç–—ç«™æ¢å¤äº†ä½ çš„éƒ¨åˆ†å¥åº·`, "positive");
            }
            
            // æ˜Ÿå°˜æ”¶é›†å™¨æ•ˆæœ
            if (gameState.facilities["æ˜Ÿå°˜æ”¶é›†å™¨"].level > 0 && gameState.weather === "æ˜Ÿå¤œ") {
                const stardust = 1 + Math.floor(Math.random() * 2);
                addItem("æ˜Ÿå°˜", stardust);
                addLog(`æ˜Ÿå°˜æ”¶é›†å™¨æ”¶é›†äº†${stardust}ä¸ªæ˜Ÿå°˜`, "star");
            }
            
            // éšæœºä¸§å°¸è¢­å‡»
            if (Math.random() < 0.3 - (0.05 * gameState.facilities["é˜²å¾¡å·¥äº‹"].level) && gameState.day - gameState.lastAttackDay > 2) {
                triggerZombieAttack();
            }
        }

        function updateTimeEffects() {
            // å¤œæ™šæ¢å¤æ›´å¤šç²¾åŠ›ä½†SANå€¼ä¸‹é™
            if (gameState.time === 3) {
                gameState.energy = Math.min(gameState.maxEnergy, gameState.energy + 40);
                gameState.san = Math.max(0, gameState.san - 5);
            } else {
                gameState.energy = Math.max(0, gameState.energy - 10);
            }
            
            // ä¸­åˆæ¸©åº¦æœ€é«˜
            if (gameState.time === 1) {
                if (gameState.weather === "æ™´å¤©") {
                    gameState.temperature += 5;
                }
            }
            
            // å¤œæ™šæ¸©åº¦æœ€ä½
            if (gameState.time === 3) {
                if (gameState.weather !== "æå¯’") {
                    gameState.temperature -= 5;
                }
            }
            
            // æå¯’å¤©æ°”ä¼¤å®³
            if (gameState.weather === "æå¯’" && gameState.temperature < -5) {
                if (!hasStatusEffect("ä¿æš–è¡£ç‰©")) {
                    const damage = Math.floor(Math.random() * 3) + 1;
                    gameState.health = Math.max(0, gameState.health - damage);
                    addLog(`æå¯’å¤©æ°”ä½¿ä½ å¤±å»äº†${damage}ç‚¹ç”Ÿå‘½å€¼`, "danger");
                }
            }
            
            // æ˜Ÿå¤œæ•ˆæœ
            if (gameState.weather === "æ˜Ÿå¤œ") {
                gameState.san = Math.min(gameState.maxSan, gameState.san + 5);
                if (hasItem("æ˜Ÿå…‰æŠ¤ç¬¦")) {
                    gameState.san = Math.min(gameState.maxSan, gameState.san + 5);
                }
            }
        }

        function processStatusEffects() {
            // å¤„ç†æœ‰é™æŒç»­æ—¶é—´çš„çŠ¶æ€æ•ˆæœ
            gameState.statusEffects = gameState.statusEffects.filter(effect => {
                if (effect.duration !== Infinity) {
                    effect.duration--;
                    return effect.duration > 0;
                }
                return true;
            });
        }

        function triggerRandomEvent() {
            const events = [
                { 
                    msg: "ä½ å¬åˆ°è¿œå¤„æœ‰å°–å«å£°", 
                    type: "info",
                    action: () => {} 
                },
                { 
                    msg: "ä¸€ç¾¤ä¸§å°¸ä»é™„è¿‘ç»è¿‡", 
                    type: "warning",
                    action: () => {
                        if (Math.random() < 0.3) {
                            addLog("ä¸§å°¸å‘ç°äº†ä½ ï¼", "danger");
                            fight();
                        }
                    } 
                },
                { 
                    msg: "æ‰¾åˆ°äº†ä¸€äº›ç‰©èµ„", 
                    type: "positive",
                    action: () => {
                        const items = ["ç½å¤´", "ç“¶è£…æ°´", "ç»·å¸¦", "æœ¨æ", "é‡‘å±"];
                        const foundItem = items[Math.floor(Math.random() * items.length)];
                        addItem(foundItem, Math.floor(Math.random() * 3) + 1);
                    }
                },
                { 
                    msg: "è¢«ä¸§å°¸æŠ“ä¼¤äº†ï¼", 
                    type: "danger",
                    action: () => {
                        const damage = 15 + Math.floor(Math.random() * 10);
                        gameState.health -= damage;
                        gameState.infection += 20;
                        gameState.san = Math.max(0, gameState.san - 10);
                        addLog(`å—åˆ°${damage}ç‚¹ä¼¤å®³å¹¶è¢«æ„ŸæŸ“`, "danger");
                    }
                },
                { 
                    msg: "å‘ç°ä¸€ä¸ªåºŸå¼ƒçš„èƒŒåŒ…", 
                    type: "positive",
                    action: () => {
                        addItem("ç»·å¸¦", 1);
                        addItem("ç½å¤´", 2);
                        if (Math.random() < 0.3) {
                            addItem("æ‰‹æª", 1);
                            addLog("èƒŒåŒ…é‡Œæœ‰ä¸€æŠŠæ‰‹æªï¼", "positive");
                        }
                    }
                },
                { 
                    msg: "é­é‡äº†ç‰¹æ®Šæ„ŸæŸ“è€…ï¼", 
                    type: "danger",
                    chance: 0.1,
                    action: () => {
                        const specialZombies = ["å°–å«è€…", "è£…ç”²ä¸§å°¸", "å‘•åè€…", "å¿«é€Ÿæ„ŸæŸ“è€…"];
                        const zombie = specialZombies[Math.floor(Math.random() * specialZombies.length)];
                        
                        let damage = 25;
                        let infection = 30;
                        
                        switch (zombie) {
                            case "è£…ç”²ä¸§å°¸":
                                damage = 15;
                                infection = 10;
                                break;
                            case "å¿«é€Ÿæ„ŸæŸ“è€…":
                                damage = 20;
                                infection = 40;
                                break;
                        }
                        
                        gameState.health -= damage;
                        gameState.infection += infection;
                        gameState.san = Math.max(0, gameState.san - 15);
                        
                        addLog(`é­é‡äº†${zombie}ï¼å—åˆ°${damage}ç‚¹ä¼¤å®³`, "danger");
                        
                        // ç‰¹æ®Šæ„ŸæŸ“è€…æœ‰é¢å¤–æ‰è½
                        if (Math.random() < 0.5) {
                            const rareItems = ["æŠ—ç”Ÿç´ ", "é•‡é™å‰‚", "ç”µå­é›¶ä»¶", "å¼¹è¯"];
                            const rareItem = rareItems[Math.floor(Math.random() * rareItems.length)];
                            addItem(rareItem, 1);
                            addLog(`å‡»è´¥${zombie}åå‘ç°äº†${rareItem}`, "positive");
                        }
                    }
                },
                { 
                    msg: "å‘ç°äº†ä¸€é¢—å è½çš„æµæ˜Ÿï¼", 
                    type: "star",
                    chance: 0.05,
                    condition: () => gameState.weather === "æ˜Ÿå¤œ",
                    action: () => {
                        addItem("æ˜Ÿå°˜", 3 + Math.floor(Math.random() * 3));
                        addLog("æ”¶é›†åˆ°äº†çè´µçš„æ˜Ÿå°˜", "star");
                    }
                },
                { 
                    msg: "å‘ç°äº†ä¸€ä¸ªç¥ç§˜çš„å¤©æ–‡å°", 
                    type: "star",
                    chance: 0.1,
                    condition: () => gameState.day > 5 && !gameState.discoveredLocations.includes("å¤©æ–‡å°"),
                    action: () => {
                        // åœ¨åœ°å›¾ä¸Šéšæœºæ”¾ç½®å¤©æ–‡å°
                        const positions = [];
                        for (let y = 0; y < 5; y++) {
                            for (let x = 0; x < 5; x++) {
                                if (!gameState.map[y][x]) {
                                    positions.push({ x, y });
                                }
                            }
                        }
                        
                        if (positions.length > 0) {
                            const pos = positions[Math.floor(Math.random() * positions.length)];
                            gameState.map[pos.y][pos.x] = "å¤©æ–‡å°";
                            addLog("åœ°å›¾ä¸Šå‡ºç°äº†ä¸€ä¸ªæ–°çš„åœ°ç‚¹ï¼šå¤©æ–‡å°", "star");
                        }
                    }
                }
            ];
            
            const roll = Math.random();
            for (const event of events) {
                // æ£€æŸ¥æ¡ä»¶
                if (event.condition && !event.condition()) continue;
                
                const chance = event.chance || 0.3;
                if (roll < chance) {
                    addLog(event.msg, event.type);
                    event.action();
                    break;
                }
            }
        }

        function triggerZombieAttack() {
            gameState.lastAttackDay = gameState.day;
            gameState.zombieHordeSize = 3 + Math.floor(Math.random() * 5) + Math.floor(gameState.day / 5);
            
            // é˜²å¾¡å·¥äº‹å‡å°‘ä¸§å°¸æ•°é‡
            gameState.zombieHordeSize = Math.max(1, gameState.zombieHordeSize - gameState.facilities["é˜²å¾¡å·¥äº‹"].level);
            
            addLog(`ä¸€ç¾¤ä¸§å°¸(${gameState.zombieHordeSize}åª)è¢­å‡»äº†ä½ çš„é¿éš¾æ‰€ï¼`, "danger");
            
            let defenseBonus = gameState.defense;
            if (gameState.equippedArmor) {
                defenseBonus += gameState.inventory[gameState.equippedArmor].defense;
            }
            
            // æˆ˜æ–—è®¡ç®—
            let damageTaken = Math.max(0, Math.floor(gameState.zombieHordeSize * 5 / (1 + defenseBonus / 10)));
            gameState.health -= damageTaken;
            
            if (gameState.health <= 0) {
                addLog("ä¸§å°¸æ”»ç ´äº†ä½ çš„é˜²å¾¡...æ¸¸æˆç»“æŸ", "danger");
            } else {
                // å‡»é€€ä¸§å°¸å¯èƒ½è·å¾—èµ„æº
                if (Math.random() < 0.5) {
                    const loot = ["æœ¨æ", "é‡‘å±", "å¸ƒæ–™"][Math.floor(Math.random() * 3)];
                    const amount = 1 + Math.floor(Math.random() * 3);
                    addItem(loot, amount);
                    addLog(`å‡»é€€ä¸§å°¸åæ‰¾åˆ°äº†${amount}ä¸ª${loot}`, "positive");
                }
                
                addLog(`å‡»é€€äº†ä¸§å°¸ç¾¤ï¼Œä½†å—åˆ°${damageTaken}ç‚¹ä¼¤å®³`, damageTaken > 10 ? "danger" : "warning");
            }
        }

        // ======================
        // ç©å®¶è¡ŒåŠ¨
        // ======================
        function explore() {
            if (gameState.energy < 20) {
                addLog("å¤ªç´¯äº†ï¼Œæ— æ³•æ¢ç´¢", "warning");
                return;
            }
            
            gameState.energy -= 20;
            
            const outcomes = [
                { 
                    msg: "æ¢ç´¢äº†å‘¨å›´åŒºåŸŸï¼Œä½†ä»€ä¹ˆä¹Ÿæ²¡æ‰¾åˆ°", 
                    chance: 0.3 
                },
                { 
                    msg: "å‘ç°äº†ä¸€äº›æœ‰ç”¨çš„ç‰©èµ„", 
                    chance: 0.4, 
                    action: () => {
                        const resources = gameState.locations[gameState.location].resources;
                        if (resources.length > 0) {
                            const resourceType = resources[Math.floor(Math.random() * resources.length)];
                            
                            switch (resourceType) {
                                case "é£Ÿç‰©":
                                    addItem(Math.random() < 0.7 ? "ç½å¤´" : "ç“¶è£…æ°´", 1 + Math.floor(Math.random() * 2));
                                    break;
                                case "åŒ»ç–—":
                                    addItem(Math.random() < 0.5 ? "ç»·å¸¦" : "æŠ—ç”Ÿç´ ", 1);
                                    break;
                                case "æ­¦å™¨":
                                    if (Math.random() < 0.3) {
                                        addItem("æ‰‹æª", 1);
                                    } else {
                                        addItem("æ£’çƒæ£", 1);
                                    }
                                    break;
                                case "å»ºæ":
                                    addItem(Math.random() < 0.5 ? "æœ¨æ" : "é‡‘å±", 2 + Math.floor(Math.random() * 3));
                                    break;
                                case "æ˜Ÿå°˜":
                                    if (gameState.weather === "æ˜Ÿå¤œ") {
                                        addItem("æ˜Ÿå°˜", 1 + Math.floor(Math.random() * 2));
                                    } else {
                                        addItem("ç”µå­é›¶ä»¶", 1);
                                    }
                                    break;
                                default:
                                    addItem("å¸ƒæ–™", 1 + Math.floor(Math.random() * 2));
                            }
                        } else {
                            addItem(["æœ¨æ", "é‡‘å±", "å¸ƒæ–™"][Math.floor(Math.random() * 3)], 1 + Math.floor(Math.random() * 2));
                        }
                    }
                },
                { 
                    msg: "é­é‡äº†ä¸§å°¸ï¼", 
                    chance: 0.3, 
                    action: () => fight()
                }
            ];
            
            const roll = Math.random();
            let cumulativeChance = 0;
            for (const outcome of outcomes) {
                cumulativeChance += outcome.chance;
                if (roll <= cumulativeChance) {
                    addLog(outcome.msg, outcome.type || "info");
                    if (outcome.action) outcome.action();
                    break;
                }
            }
            
            // æ¢ç´¢é™ä½SANå€¼
            if (gameState.location !== "é¿éš¾æ‰€") {
                gameState.san = Math.max(0, gameState.san - 5);
            }
            
            updateUI();
        }

        function scavenge() {
            if (gameState.energy < 15) {
                addLog("å¤ªç´¯äº†ï¼Œæ— æ³•æœåˆ®", "warning");
                return;
            }
            
            if (gameState.location === "é¿éš¾æ‰€") {
                addLog("è¿™é‡Œæ²¡æœ‰æ›´å¤šç‰©èµ„äº†", "info");
                return;
            }
            
            gameState.energy -= 15;
            
            // æœåˆ®æœ‰æ›´é«˜å‡ ç‡æ‰¾åˆ°ç‰©èµ„ä½†ä¹Ÿæ›´å±é™©
            const outcomes = [
                { 
                    msg: "ä»”ç»†æœåˆ®ä½†æ²¡æœ‰å‘ç°ä»»ä½•ä¸œè¥¿", 
                    chance: 0.2 
                },
                { 
                    msg: "æ‰¾åˆ°äº†ä¸€äº›ç‰©èµ„", 
                    chance: 0.5, 
                    action: () => {
                        const resources = gameState.locations[gameState.location].resources;
                        let itemCount = 0;
                        
                        for (let i = 0; i < 3; i++) {
                            if (resources.length > 0 && Math.random() < 0.7) {
                                const resourceType = resources[Math.floor(Math.random() * resources.length)];
                                
                                switch (resourceType) {
                                    case "é£Ÿç‰©":
                                        addItem(Math.random() < 0.7 ? "ç½å¤´" : "ç“¶è£…æ°´", 1);
                                        break;
                                    case "åŒ»ç–—":
                                        addItem(Math.random() < 0.5 ? "ç»·å¸¦" : "æŠ—ç”Ÿç´ ", 1);
                                        break;
                                    case "æ­¦å™¨":
                                        if (Math.random() < 0.2) {
                                            addItem("æ‰‹æª", 1);
                                        } else {
                                            addItem("æ£’çƒæ£", 1);
                                        }
                                        break;
                                    case "å»ºæ":
                                        addItem(Math.random() < 0.5 ? "æœ¨æ" : "é‡‘å±", 1);
                                        break;
                                    case "æ˜Ÿå°˜":
                                        if (gameState.weather === "æ˜Ÿå¤œ") {
                                            addItem("æ˜Ÿå°˜", 1);
                                        } else {
                                            addItem("ç”µå­é›¶ä»¶", 1);
                                        }
                                        break;
                                    default:
                                        addItem("å¸ƒæ–™", 1);
                                }
                                itemCount++;
                            }
                        }
                        
                        if (itemCount === 0) {
                            addItem(["æœ¨æ", "é‡‘å±", "å¸ƒæ–™"][Math.floor(Math.random() * 3)], 1);
                        }
                    }
                },
                { 
                    msg: "æœåˆ®æ—¶æƒŠåŠ¨äº†ä¸§å°¸ï¼", 
                    chance: 0.3, 
                    action: () => {
                        // æœåˆ®é­é‡æˆ˜æ›´å±é™©
                        gameState.health -= 5;
                        addLog("æœåˆ®å£°éŸ³å¼•æ¥äº†æ›´å¤šä¸§å°¸", "danger");
                        fight();
                    }
                }
            ];
            
            const roll = Math.random();
            let cumulativeChance = 0;
            for (const outcome of outcomes) {
                cumulativeChance += outcome.chance;
                if (roll <= cumulativeChance) {
                    addLog(outcome.msg, outcome.type || "info");
                    if (outcome.action) outcome.action();
                    break;
                }
            }
            
            // æœåˆ®å¤§å¹…é™ä½SANå€¼
            gameState.san = Math.max(0, gameState.san - 10);
            updateUI();
        }

        function rest() {
            if (gameState.location !== "é¿éš¾æ‰€") {
                addLog("åªæœ‰é¿éš¾æ‰€æ‰èƒ½å®‰å…¨ä¼‘æ¯", "warning");
                return;
            }
            
            const healthRecovered = Math.min(20, gameState.maxHealth - gameState.health);
            gameState.health += healthRecovered;
            gameState.energy = Math.min(gameState.maxEnergy, gameState.energy + 30);
            gameState.san = Math.min(gameState.maxSan, gameState.san + 5);
            
            addLog(`ä¼‘æ¯æ¢å¤äº† ${healthRecovered} ç‚¹ç”Ÿå‘½å€¼å’Œ 30 ç‚¹ç²¾åŠ›`, "positive");
            updateUI();
        }

        function eat() {
            if (useItem("ç½å¤´", 1)) {
                gameState.hunger = Math.min(gameState.maxHunger, gameState.hunger + 30);
                addLog("åƒäº†ä¸€ä¸ªç½å¤´ï¼Œä¸é‚£ä¹ˆé¥¿äº†", "positive");
            } else if (useItem("ç“¶è£…æ°´", 1)) {
                gameState.hunger = Math.min(gameState.maxHunger, gameState.hunger + 10);
                addLog("å–äº†ä¸€ç“¶æ°´ï¼Œç¨å¾®ç¼“è§£äº†é¥¥æ¸´", "info");
            } else {
                addLog("æ²¡æœ‰é£Ÿç‰©å¯åƒ", "warning");
            }
            updateUI();
        }

        function fight() {
            if (gameState.energy < 15) {
                addLog("å¤ªç´¯äº†ï¼Œæ— æ³•æœ‰æ•ˆæˆ˜æ–—", "warning");
                return;
            }
            
            gameState.energy -= 15;
            
            let baseDamage = 10;
            if (gameState.equippedWeapon) {
                const weapon = gameState.inventory[gameState.equippedWeapon];
                baseDamage = weapon.damage;
                
                // æ­¦å™¨è€ä¹…æŸè€—
                weapon.durability = Math.max(0, weapon.durability - 5);
                if (weapon.durability <= 0) {
                    addLog(`${gameState.equippedWeapon}æŸåäº†ï¼`, "danger");
                    weapon.count--;
                    if (weapon.count <= 0) {
                        delete gameState.inventory[gameState.equippedWeapon];
                        gameState.equippedWeapon = null;
                    }
                }
                
                // è¿œç¨‹æ­¦å™¨éœ€è¦å¼¹è¯
                if (gameState.equippedWeapon === "æ‰‹æª") {
                    if (weapon.ammo <= 0) {
                        addLog("æ²¡æœ‰å¼¹è¯äº†ï¼", "danger");
                        baseDamage = 5; // ä»ç„¶å¯ä»¥ç”¨æªæ‰˜æ”»å‡»
                    } else {
                        weapon.ammo--;
                    }
                }
            }
            
            // åº”ç”¨æŠ€èƒ½åŠ æˆ
            if (gameState.equippedWeapon && gameState.equippedWeapon === "æ‰‹æª") {
                baseDamage *= gameState.rangedDamageBonus;
            } else if (gameState.equippedWeapon) {
                baseDamage *= gameState.meleeDamageBonus;
            }
            
            const damage = Math.floor(baseDamage * (0.8 + Math.random() * 0.4));
            
            if (Math.random() < 0.7) { // 70% æˆåŠŸå‡ ç‡
                let damageTaken = Math.floor(Math.random() * 15) + 5 - Math.floor(gameState.defense / 3);
                
                if (gameState.equippedArmor) {
                    const armor = gameState.inventory[gameState.equippedArmor];
                    damageTaken = Math.max(0, damageTaken - armor.defense);
                    
                    // æŠ¤ç”²è€ä¹…æŸè€—
                    armor.durability = Math.max(0, armor.durability - 3);
                    if (armor.durability <= 0) {
                        addLog(`${gameState.equippedArmor}æŸåäº†ï¼`, "danger");
                        armor.count--;
                        if (armor.count <= 0) {
                            delete gameState.inventory[gameState.equippedArmor];
                            gameState.equippedArmor = null;
                        }
                    }
                }
                
                gameState.health -= Math.max(0, damageTaken);
                
                if (Math.random() < 0.4) { // 40% å‡ ç‡è¢«æ„ŸæŸ“
                    const infectionAmount = 10 + Math.floor(Math.random() * 5);
                    gameState.infection += infectionAmount;
                    addLog(`å‡»é€€äº†ä¸§å°¸ä½†å—åˆ° ${damageTaken} ç‚¹ä¼¤å®³å¹¶è¢«æ„ŸæŸ“(+${infectionAmount})`, "danger");
                } else {
                    addLog(`å‡»é€€äº†ä¸§å°¸ä½†å—åˆ° ${damageTaken} ç‚¹ä¼¤å®³`, damageTaken > 10 ? "danger" : "warning");
                }
                
                // æˆ˜æ–—å¥–åŠ±
                if (Math.random() < 0.6) {
                    const loot = ["ç»·å¸¦", "ç½å¤´", "æœ¨æ", "é‡‘å±"][Math.floor(Math.random() * 4)];
                    addItem(loot, 1);
                }
                
                // ä½æ¦‚ç‡è·å¾—ç¨€æœ‰ç‰©å“
                if (Math.random() < 0.1) {
                    const rareLoot = ["æŠ—ç”Ÿç´ ", "é•‡é™å‰‚", "ç”µå­é›¶ä»¶", "å¼¹è¯", "æ˜Ÿå°˜"][Math.floor(Math.random() * 5)];
                    addItem(rareLoot, 1);
                    addLog(`ä»ä¸§å°¸èº«ä¸Šæ‰¾åˆ°äº†${rareLoot}ï¼`, rareLoot === "æ˜Ÿå°˜" ? "star" : "positive");
                }
            } else {
                addLog("æˆåŠŸå‡»é€€ä¸§å°¸ä¸”æœªå—ä¼¤", "positive");
                if (Math.random() < 0.7) {
                    addItem("ç½å¤´", 2);
                }
            }
            
            // æˆ˜æ–—é™ä½SANå€¼
            gameState.san = Math.max(0, gameState.san - 10);
            
            updateUI();
        }

        function craft() {
            openCraftModal();
        }

        function build() {
            openBuildModal();
        }

        function showSkills() {
            openSkillsModal();
        }

        function treat() {
            if (useItem("ç»·å¸¦", 1)) {
                const healing = Math.floor(20 * gameState.healingBonus);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + healing);
                addLog(`ä½¿ç”¨ç»·å¸¦æ¢å¤äº†${healing}ç‚¹ç”Ÿå‘½å€¼`, "positive");
            } else if (useItem("æŠ—ç”Ÿç´ ", 1)) {
                gameState.infection = Math.max(0, gameState.infection - 30);
                addLog("ä½¿ç”¨æŠ—ç”Ÿç´ é™ä½äº†æ„ŸæŸ“ç¨‹åº¦", "positive");
            } else if (useItem("é•‡é™å‰‚", 1)) {
                gameState.san = Math.min(gameState.maxSan, gameState.san + 20);
                addLog("ä½¿ç”¨é•‡é™å‰‚ç¨³å®šäº†ç²¾ç¥çŠ¶æ€", "positive");
            } else {
                addLog("æ²¡æœ‰å¯ç”¨çš„åŒ»ç–—ç‰©å“", "warning");
            }
            updateUI();
        }

        function travel(x, y) {
            if (x < 0 || x >= 5 || y < 0 || y >= 5) {
                addLog("æ— æ³•å‘é‚£ä¸ªæ–¹å‘ç§»åŠ¨", "warning");
                return;
            }
            
            const destination = gameState.map[y][x];
            if (!destination) {
                addLog("é‚£é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰", "info");
                return;
            }
            
            if (destination === gameState.location) {
                addLog("ä½ å·²ç»åœ¨è¿™é‡Œäº†", "info");
                return;
            }
            
            // æ—…è¡Œæ¶ˆè€—èƒ½é‡
            const distance = Math.abs(x - gameState.currentPosition.x) + Math.abs(y - gameState.currentPosition.y);
            const energyCost = distance * 10;
            
            if (gameState.energy < energyCost) {
                addLog("æ²¡æœ‰è¶³å¤Ÿçš„ç²¾åŠ›å‰å¾€é‚£é‡Œ", "warning");
                return;
            }
            
            gameState.energy -= energyCost;
            gameState.currentPosition = { x, y };
            gameState.location = destination;
            
            // å‘ç°æ–°åœ°ç‚¹
            if (!gameState.discoveredLocations.includes(destination)) {
                gameState.discoveredLocations.push(destination);
                addLog(`å‘ç°äº†æ–°çš„åœ°ç‚¹ï¼š${destination}`, "positive");
                
                // å‘ç°æ–°åœ°ç‚¹å¥–åŠ±
                gameState.skillPoints++;
                addLog("å› æ¢ç´¢è·å¾—1ç‚¹æŠ€èƒ½ç‚¹", "positive");
            }
            
            // æ›´æ–°ä½ç½®æè¿°
            elements["location-description"].textContent = gameState.locations[destination].description;
            
            // æ—…è¡Œå¯èƒ½é­é‡éšæœºäº‹ä»¶
            if (Math.random() < 0.4) {
                triggerRandomEvent();
            }
            
            addLog(`ç§»åŠ¨åˆ°äº†${destination}`, "info");
            updateUI();
        }

        // ======================
        // ä¿å­˜å’ŒåŠ è½½åŠŸèƒ½
        // ======================
        function saveGame(slot = 1) {
            try {
                const saveData = JSON.stringify(gameState);
                localStorage.setItem(`survival_star_save_${slot}`, saveData);
                addLog(`æ¸¸æˆå·²ä¿å­˜åˆ°å­˜æ¡£ ${slot}`, "positive");
                return true;
            } catch (e) {
                addLog("ä¿å­˜æ¸¸æˆå¤±è´¥", "danger");
                console.error("ä¿å­˜é”™è¯¯:", e);
                return false;
            }
        }

        function loadGame(slot = 1) {
            try {
                const saveData = localStorage.getItem(`survival_star_save_${slot}`);
                if (!saveData) {
                    addLog(`å­˜æ¡£ ${slot} ä¸å­˜åœ¨`, "warning");
                    return false;
                }
                
                const loadedState = JSON.parse(saveData);
                
                // ç®€å•éªŒè¯å­˜æ¡£æ•°æ®
                if (!loadedState.version || !loadedState.day || !loadedState.inventory) {
                    addLog("å­˜æ¡£æ•°æ®æŸå", "danger");
                    return false;
                }
                
                // åˆå¹¶åŠ è½½çš„çŠ¶æ€åˆ°å½“å‰æ¸¸æˆçŠ¶æ€
                Object.assign(gameState, loadedState);
                
                // å…³é—­åŠ è½½æ¨¡æ€æ¡†
                document.getElementById("load-modal").style.display = "none";
                
                addLog(`ä»å­˜æ¡£ ${slot} åŠ è½½æ¸¸æˆ`, "positive");
                updateUI();
                return true;
            } catch (e) {
                addLog("åŠ è½½æ¸¸æˆå¤±è´¥", "danger");
                console.error("åŠ è½½é”™è¯¯:", e);
                return false;
            }
        }

        function openLoadModal() {
            document.getElementById("load-modal").style.display = "block";
        }

        // ======================
        // ç‰©å“å’Œè£…å¤‡ç®¡ç†
        // ======================
        function addItem(item, quantity = 1) {
            if (!gameState.inventory[item]) {
                // å¦‚æœæ˜¯æ–°ç‰©å“ï¼Œåˆå§‹åŒ–å®ƒçš„å±æ€§
                switch (item) {
                    case "æœ¨åˆ¶é•¿çŸ›":
                        gameState.inventory[item] = { type: "weapon", count: 0, damage: 12, durability: 40 };
                        break;
                    case "ç®€æ˜“é™·é˜±":
                        gameState.inventory[item] = { type: "tool", count: 0, effect: "å¢åŠ æœåˆ®æˆåŠŸç‡" };
                        break;
                    case "é“åˆ¶æŠ¤ç”²":
                        gameState.inventory[item] = { type: "armor", count: 0, defense: 6, durability: 50 };
                        break;
                    case "æ˜Ÿå…‰æŠ¤ç¬¦":
                        gameState.inventory[item] = { type: "trinket", count: 0, effect: { san: 10 } };
                        break;
                    default:
                        gameState.inventory[item] = { type: "resource", count: 0 };
                }
            }
            
            gameState.inventory[item].count += quantity;
            return true;
        }

        function useItem(item, quantity = 1) {
            if (gameState.inventory[item] && gameState.inventory[item].count >= quantity) {
                gameState.inventory[item].count -= quantity;
                
                if (gameState.inventory[item].count <= 0) {
                    delete gameState.inventory[item];
                    
                    // å¦‚æœè£…å¤‡è¢«ç”¨å®Œï¼Œå–æ¶ˆè£…å¤‡
                    if (gameState.equippedWeapon === item) {
                        gameState.equippedWeapon = null;
                    }
                    if (gameState.equippedArmor === item) {
                        gameState.equippedArmor = null;
                    }
                }
                
                return true;
            }
            return false;
        }

        function equipItem(item) {
            if (!gameState.inventory[item]) return false;
            
            const itemData = gameState.inventory[item];
            
            if (itemData.type === "weapon") {
                gameState.equippedWeapon = item;
                addLog(`è£…å¤‡äº†${item}`, "positive");
                return true;
            } else if (itemData.type === "armor") {
                gameState.equippedArmor = item;
                addLog(`è£…å¤‡äº†${item}`, "positive");
                return true;
            } else if (itemData.type === "trinket") {
                // é¥°å“è‡ªåŠ¨ç”Ÿæ•ˆ
                if (itemData.effect) {
                    if (itemData.effect.san) {
                        gameState.san = Math.min(gameState.maxSan, gameState.san + itemData.effect.san);
                    }
                    addLog(`ä½¿ç”¨äº†${item}ï¼Œæ•ˆæœç”Ÿæ•ˆ`, "star");
                }
                return true;
            }
            
            return false;
        }

        function hasItem(item, quantity = 1) {
            return gameState.inventory[item] && gameState.inventory[item].count >= quantity;
        }

        function hasStatusEffect(effectName) {
            return gameState.statusEffects.some(effect => effect.name === effectName);
        }

        // ======================
        // åˆ¶ä½œç³»ç»Ÿ
        // ======================
        function openCraftModal() {
            const modal = document.getElementById("craft-modal");
            const recipesContainer = document.getElementById("craft-recipes");
            
            recipesContainer.innerHTML = "";
            
            // æ˜¾ç¤ºæ‰€æœ‰å¯åˆ¶ä½œçš„é…æ–¹
            for (const [recipeName, recipe] of Object.entries(gameState.recipes)) {
                // æ£€æŸ¥æ˜¯å¦æ»¡è¶³å‰ææ¡ä»¶
                let canCraft = true;
                if (recipe.requires) {
                    for (const [facility, level] of Object.entries(recipe.requires)) {
                        if (gameState.facilities[facility].level < level) {
                            canCraft = false;
                            break;
                        }
                    }
                }
                
                // æ£€æŸ¥ææ–™æ˜¯å¦è¶³å¤Ÿ
                for (const [material, amount] of Object.entries(recipe.materials)) {
                    if (!hasItem(material, amount)) {
                        canCraft = false;
                        break;
                    }
                }
                
                const recipeElement = document.createElement("div");
                recipeElement.className = "recipe";
                recipeElement.style.opacity = canCraft ? 1 : 0.5;
                
                let html = `<div class="recipe-name">${recipeName}</div>`;
                html += `<div class="recipe-materials">éœ€è¦: `;
                
                for (const [material, amount] of Object.entries(recipe.materials)) {
                    html += `${material} x${amount} `;
                }
                
                html += `</div>`;
                
                if (recipe.requires) {
                    html += `<div class="recipe-requirements">å‰æ: `;
                    for (const [facility, level] of Object.entries(recipe.requires)) {
                        html += `${facility} Lv.${level} `;
                    }
                    html += `</div>`;
                }
                
                if (recipe.effect) {
                    html += `<div class="recipe-effect">æ•ˆæœ: ${recipe.effect.description || "æœªçŸ¥"}</div>`;
                }
                
                if (canCraft) {
                    html += `<button class="btn" onclick="craftItem('${recipeName}')" style="width: 100%; margin-top: 5px;">åˆ¶ä½œ</button>`;
                } else {
                    html += `<button class="btn btn-disabled" style="width: 100%; margin-top: 5px;" disabled>æ— æ³•åˆ¶ä½œ</button>`;
                }
                
                recipeElement.innerHTML = html;
                recipesContainer.appendChild(recipeElement);
            }
            
            modal.style.display = "block";
        }

        function craftItem(recipeName) {
            const recipe = gameState.recipes[recipeName];
            
            // å†æ¬¡æ£€æŸ¥ææ–™
            for (const [material, amount] of Object.entries(recipe.materials)) {
                if (!hasItem(material, amount)) {
                    addLog(`åˆ¶ä½œ${recipeName}ç¼ºå°‘${material}`, "warning");
                    return;
                }
            }
            
            // æ¶ˆè€—ææ–™
            for (const [material, amount] of Object.entries(recipe.materials)) {
                useItem(material, amount);
            }
            
            // æ·»åŠ æˆå“
            const resultItem = Object.keys(recipe.result)[0];
            const resultAmount = recipe.result[resultItem];
            
            addItem(resultItem, resultAmount);
            addLog(`æˆåŠŸåˆ¶ä½œäº†${resultItem} x${resultAmount}`, recipe.type === "trinket" ? "star" : "positive");
            
            // å…³é—­æ¨¡æ€æ¡†
            document.getElementById("craft-modal").style.display = "none";
            updateUI();
        }

        // ======================
        // å»ºé€ ç³»ç»Ÿ
        // ======================
        function openBuildModal() {
            const modal = document.getElementById("build-modal");
            const buildContainer = document.getElementById("build-options");
            
            buildContainer.innerHTML = "";
            
            // æ˜¾ç¤ºæ‰€æœ‰å¯å»ºé€ /å‡çº§çš„è®¾æ–½
            for (const [facilityName, facility] of Object.entries(gameState.facilities)) {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡çº§
                const canUpgrade = facility.level < facility.maxLevel;
                
                // æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
                let canBuild = true;
                if (canUpgrade) {
                    for (const [material, amount] of Object.entries(facility.requirements)) {
                        if (!hasItem(material, amount)) {
                            canBuild = false;
                            break;
                        }
                    }
                }
                
                const facilityElement = document.createElement("div");
                facilityElement.className = "facility";
                
                let html = `<div><strong>${facilityName}</strong> Lv.${facility.level}/${facility.maxLevel}</div>`;
                html += `<div style="font-size: 12px; margin: 5px 0;">${facility.description}</div>`;
                
                if (canUpgrade) {
                    html += `<div style="font-size: 12px; margin-bottom: 5px;">å‡çº§éœ€è¦: `;
                    for (const [material, amount] of Object.entries(facility.requirements)) {
                        html += `${material} x${amount} `;
                    }
                    html += `</div>`;
                    
                    if (canBuild) {
                        html += `<button class="btn" onclick="upgradeFacility('${facilityName}')" style="width: 100%;">å‡çº§</button>`;
                    } else {
                        html += `<button class="btn btn-disabled" style="width: 100%;" disabled>èµ„æºä¸è¶³</button>`;
                    }
                } else {
                    html += `<div style="font-size: 12px; color: #999;">å·²è¾¾åˆ°æœ€å¤§ç­‰çº§</div>`;
                }
                
                facilityElement.innerHTML = html;
                buildContainer.appendChild(facilityElement);
            }
            
            modal.style.display = "block";
        }

        function upgradeFacility(facilityName) {
            const facility = gameState.facilities[facilityName];
            
            // å†æ¬¡æ£€æŸ¥æ˜¯å¦å¯ä»¥å‡çº§
            if (facility.level >= facility.maxLevel) {
                addLog(`${facilityName}å·²ç»è¾¾åˆ°æœ€å¤§ç­‰çº§`, "warning");
                return;
            }
            
            // æ£€æŸ¥ææ–™
            for (const [material, amount] of Object.entries(facility.requirements)) {
                if (!hasItem(material, amount)) {
                    addLog(`å‡çº§${facilityName}ç¼ºå°‘${material}`, "warning");
                    return;
                }
            }
            
            // æ¶ˆè€—ææ–™
            for (const [material, amount] of Object.entries(facility.requirements)) {
                useItem(material, amount);
            }
            
            // å‡çº§è®¾æ–½
            facility.level++;
            addLog(`${facilityName}å·²å‡çº§åˆ°ç­‰çº§ ${facility.level}`, "positive");
            
            // å…³é—­æ¨¡æ€æ¡†
            document.getElementById("build-modal").style.display = "none";
            updateUI();
        }

        // ======================
        // æŠ€èƒ½ç³»ç»Ÿ
        // ======================
        function openSkillsModal() {
            const modal = document.getElementById("skills-modal");
            const skillPointsElement = document.getElementById("skill-points");
            const skillTreesContainer = document.getElementById("skill-trees");
            
            skillPointsElement.textContent = gameState.skillPoints;
            skillTreesContainer.innerHTML = "";
            
            // æ˜¾ç¤ºæ‰€æœ‰æŠ€èƒ½
            for (const [skillName, skill] of Object.entries(gameState.skills)) {
                const skillElement = document.createElement("div");
                skillElement.className = "skill";
                
                // ç¡®å®šæŠ€èƒ½çŠ¶æ€
                if (skill.learned) {
                    skillElement.classList.add("learned");
                } else {
                    // æ£€æŸ¥å‰ææ¡ä»¶
                    let requirementsMet = true;
                    for (const req of skill.requirements) {
                        if (!gameState.skills[req].learned) {
                            requirementsMet = false;
                            break;
                        }
                    }
                    
                    if (requirementsMet && gameState.skillPoints >= skill.cost) {
                        skillElement.classList.add("available");
                    } else {
                        skillElement.classList.add("unavailable");
                    }
                }
                
                let html = `<div><strong>${skillName}</strong></div>`;
                html += `<div style="font-size: 12px; margin: 5px 0;">${skill.description}</div>`;
                html += `<div style="font-size: 11px; color: #999;">æ¶ˆè€—: ${skill.cost}ç‚¹`;
                
                if (skill.requirements.length > 0) {
                    html += ` | å‰æ: ${skill.requirements.join(", ")}`;
                }
                
                html += `</div>`;
                
                if (!skill.learned) {
                    if (skillElement.classList.contains("available")) {
                        html += `<button class="btn" onclick="learnSkill('${skillName}')" style="width: 100%; margin-top: 5px;">å­¦ä¹ </button>`;
                    } else {
                        html += `<button class="btn btn-disabled" style="width: 100%; margin-top: 5px;" disabled>æ— æ³•å­¦ä¹ </button>`;
                    }
                } else {
                    html += `<button class="btn btn-disabled" style="width: 100%; margin-top: 5px;" disabled>å·²å­¦ä¹ </button>`;
                }
                
                skillElement.innerHTML = html;
                skillTreesContainer.appendChild(skillElement);
            }
            
            modal.style.display = "block";
        }

        function learnSkill(skillName) {
            const skill = gameState.skills[skillName];
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å­¦ä¼š
            if (skill.learned) {
                addLog(`å·²ç»å­¦ä¼šäº†${skillName}`, "warning");
                return;
            }
            
            // æ£€æŸ¥æŠ€èƒ½ç‚¹
            if (gameState.skillPoints < skill.cost) {
                addLog(`æŠ€èƒ½ç‚¹ä¸è¶³ï¼Œæ— æ³•å­¦ä¹ ${skillName}`, "warning");
                return;
            }
            
            // æ£€æŸ¥å‰ææ¡ä»¶
            for (const req of skill.requirements) {
                if (!gameState.skills[req].learned) {
                    addLog(`å­¦ä¹ ${skillName}éœ€è¦å…ˆå­¦ä¹ ${req}`, "warning");
                    return;
                }
            }
            
            // å­¦ä¹ æŠ€èƒ½
            gameState.skillPoints -= skill.cost;
            skill.learned = true;
            
            // åº”ç”¨æŠ€èƒ½æ•ˆæœ
            if (skill.effect) {
                skill.effect();
            }
            
            addLog(`å­¦ä¼šäº†æ–°æŠ€èƒ½ï¼š${skillName}`, "positive");
            
            // åˆ·æ–°æŠ€èƒ½ç•Œé¢
            openSkillsModal();
            updateUI();
        }

        // ======================
        // æ˜Ÿçƒç‰¹æ•ˆ
        // ======================
        function createStarParticles() {
            // æ¸…é™¤ç°æœ‰çš„ç²’å­
            document.querySelectorAll('.star-particle').forEach(el => el.remove());
            
            // åˆ›å»ºæ–°çš„ç²’å­
            const particleCount = 10 + Math.floor(Math.random() * 10);
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'star-particle';
                
                // éšæœºä½ç½®
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const size = 1 + Math.random() * 2;
                const duration = 1 + Math.random() * 2;
                
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.animationDuration = `${duration}s`;
                
                document.body.appendChild(particle);
                
                // ç²’å­æ¶ˆå¤±
                setTimeout(() => {
                    particle.remove();
                }, duration * 1000);
            }
        }

        // ======================
        // UIæ›´æ–°å’Œåˆå§‹åŒ–
        // ======================
        function updateUI() {
            // æ›´æ–°åŸºç¡€çŠ¶æ€
            elements.day.textContent = gameState.day;
            elements.time.textContent = gameState.times[gameState.time];
            elements["location-tag"].textContent = gameState.location;
            elements["temperature"].textContent = `ğŸŒ¡ï¸ ${gameState.temperature}Â°C`;
            elements["weather"].textContent = gameState.weatherIcons[gameState.weathers.indexOf(gameState.weather)];
            
            // æ›´æ–°çŠ¶æ€å€¼å’Œè¿›åº¦æ¡
            elements.health.textContent = `${gameState.health}/${gameState.maxHealth}`;
            elements.hunger.textContent = `${gameState.hunger}/${gameState.maxHunger}`;
            elements.energy.textContent = `${gameState.energy}/${gameState.maxEnergy}`;
            elements.infection.textContent = `${gameState.infection}/${gameState.maxInfection}`;
            elements.san.textContent = `${gameState.san}/${gameState.maxSan}`;
            
            elements["health-bar"].style.width = `${(gameState.health / gameState.maxHealth) * 100}%`;
            elements["hunger-bar"].style.width = `${(gameState.hunger / gameState.maxHunger) * 100}%`;
            elements["energy-bar"].style.width = `${(gameState.energy / gameState.maxEnergy) * 100}%`;
            elements["infection-bar"].style.width = `${(gameState.infection / gameState.maxInfection) * 100}%`;
            elements["san-bar"].style.width = `${(gameState.san / gameState.maxSan) * 100}%`;
            
            // æ›´æ–°é˜²å¾¡å€¼
            let defense = gameState.defense;
            if (gameState.equippedArmor) {
                defense += gameState.inventory[gameState.equippedArmor].defense;
            }
            elements.defense.textContent = defense;
            
            // æ›´æ–°ç‰©å“æ 
            updateInventoryUI();
            
            // æ›´æ–°çŠ¶æ€æ•ˆæœ
            updateStatusEffectsUI();
            
            // æ›´æ–°åœ°å›¾
            updateMapUI();
            
            // æ ¹æ®çŠ¶æ€ç¦ç”¨æŒ‰é’®
            updateButtonStates();
        }

        function updateInventoryUI() {
            const itemsContainer = document.getElementById("inventory-items");
            const weaponsContainer = document.getElementById("inventory-weapons");
            const armorContainer = document.getElementById("inventory-armor");
            const resourcesContainer = document.getElementById("inventory-resources");
            
            itemsContainer.innerHTML = "";
            weaponsContainer.innerHTML = "";
            armorContainer.innerHTML = "";
            resourcesContainer.innerHTML = "";
            
            for (const [itemName, itemData] of Object.entries(gameState.inventory)) {
                const itemElement = document.createElement("div");
                itemElement.className = "item";
                
                let countText = `x${itemData.count}`;
                if (itemData.type === "weapon" && itemData.ammo !== undefined) {
                    countText = `(${itemData.ammo}/${itemData.maxAmmo})`;
                } else if (itemData.durability !== undefined) {
                    countText = `${Math.floor((itemData.durability / (itemData.maxDurability || 100)) * 100)}%`;
                }
                
                itemElement.innerHTML = `
                    <div>${itemName}</div>
                    <div class="item-count">${countText}</div>
                `;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                if (itemData.type === "medical") {
                    itemElement.addEventListener("click", () => {
                        if (itemName === "ç»·å¸¦") {
                            treat();
                        } else if (itemName === "æŠ—ç”Ÿç´ ") {
                            treat();
                        } else if (itemName === "é•‡é™å‰‚") {
                            treat();
                        }
                    });
                } else if (itemData.type === "weapon" || itemData.type === "armor" || itemData.type === "trinket") {
                    itemElement.addEventListener("click", () => {
                        equipItem(itemName);
                    });
                }
                
                // åˆ†ç±»æ˜¾ç¤º
                switch (itemData.type) {
                    case "weapon":
                        weaponsContainer.appendChild(itemElement.cloneNode(true));
                        break;
                    case "armor":
                        armorContainer.appendChild(itemElement.cloneNode(true));
                        break;
                    case "resource":
                        resourcesContainer.appendChild(itemElement.cloneNode(true));
                        break;
                    case "trinket":
                        itemsContainer.appendChild(itemElement);
                        break;
                    default:
                        itemsContainer.appendChild(itemElement);
                }
            }
        }

        function updateStatusEffectsUI() {
            const container = document.getElementById("status-effects");
            container.innerHTML = "";
            
            // åº‡æŠ¤æ‰€åŸºç¡€æ•ˆæœ
            const shelterEffect = document.createElement("div");
            shelterEffect.className = "status-effect effect-buff";
            shelterEffect.textContent = "åº‡æŠ¤æ‰€ +5é˜²å¾¡";
            container.appendChild(shelterEffect);
            
            // è£…å¤‡æ•ˆæœ
            if (gameState.equippedArmor) {
                const armorEffect = document.createElement("div");
                armorEffect.className = "status-effect effect-buff";
                armorEffect.textContent = `${gameState.equippedArmor} +${gameState.inventory[gameState.equippedArmor].defense}é˜²å¾¡`;
                container.appendChild(armorEffect);
            }
            
            // æ„ŸæŸ“æ•ˆæœ
            if (gameState.infection > 0) {
                const infectionEffect = document.createElement("div");
                infectionEffect.className = "status-effect effect-debuff";
                
                if (gameState.infection < 30) {
                    infectionEffect.textContent = "è½»å¾®æ„ŸæŸ“";
                } else if (gameState.infection < 70) {
                    infectionEffect.textContent = "ä¸­åº¦æ„ŸæŸ“";
                } else {
                    infectionEffect.textContent = "é‡åº¦æ„ŸæŸ“";
                }
                
                container.appendChild(infectionEffect);
            }
            
            // æ˜Ÿå…‰æŠ¤ç¬¦æ•ˆæœ
            if (hasItem("æ˜Ÿå…‰æŠ¤ç¬¦")) {
                const starEffect = document.createElement("div");
                starEffect.className = "status-effect effect-star";
                starEffect.textContent = "æ˜Ÿå…‰æŠ¤ç¬¦ +SANå€¼";
                container.appendChild(starEffect);
            }
            
            // å…¶ä»–çŠ¶æ€æ•ˆæœ
            for (const effect of gameState.statusEffects) {
                if (effect.name !== "åº‡æŠ¤æ‰€") {
                    const effectElement = document.createElement("div");
                    effectElement.className = `status-effect effect-${effect.type === "buff" ? "buff" : "debuff"}`;
                    effectElement.textContent = effect.name;
                    container.appendChild(effectElement);
                }
            }
        }

        function updateMapUI() {
            const mapGrid = document.getElementById("map-grid");
            mapGrid.innerHTML = "";
            
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const location = gameState.map[y][x];
                    const tile = document.createElement("div");
                    tile.className = "map-tile";
                    
                    if (!location) {
                        tile.textContent = "ï¼Ÿ";
                        tile.classList.add("undiscovered");
                    } else {
                        if (gameState.discoveredLocations.includes(location)) {
                            tile.textContent = location.substring(0, 2);
                            tile.classList.add("discovered");
                            
                            if (location === gameState.location) {
                                tile.classList.add("current");
                            }
                            
                            tile.addEventListener("click", () => travel(x, y));
                        } else {
                            tile.textContent = "ï¼Ÿ";
                            tile.classList.add("undiscovered");
                        }
                    }
                    
                    mapGrid.appendChild(tile);
                }
            }
        }

        function updateButtonStates() {
            // æ ¹æ®èƒ½é‡å€¼ç¦ç”¨æŒ‰é’®
            const energyButtons = ["btn-explore", "btn-scavenge", "btn-fight"];
            for (const btnId of energyButtons) {
                const btn = document.getElementById(btnId);
                if (gameState.energy < 15) {
                    btn.classList.add("btn-disabled");
                } else {
                    btn.classList.remove("btn-disabled");
                }
            }
            
            // æ ¹æ®ä½ç½®ç¦ç”¨ä¼‘æ¯æŒ‰é’®
            document.getElementById("btn-rest").classList.toggle("btn-disabled", gameState.location !== "é¿éš¾æ‰€");
            
            // æ ¹æ®æ˜¯å¦æœ‰é£Ÿç‰©ç¦ç”¨è¿›é£ŸæŒ‰é’®
            document.getElementById("btn-eat").classList.toggle("btn-disabled", 
                !hasItem("ç½å¤´") && !hasItem("ç“¶è£…æ°´"));
            
            // æ ¹æ®æ˜¯å¦æœ‰åŒ»ç–—ç‰©å“ç¦ç”¨æ²»ç–—æŒ‰é’®
            document.getElementById("btn-treat").classList.toggle("btn-disabled", 
                !hasItem("ç»·å¸¦") && !hasItem("æŠ—ç”Ÿç´ ") && !hasItem("é•‡é™å‰‚"));
        }

        function addLog(message, type = "info") {
            const timeLabel = gameState.times[gameState.time];
            const logEntry = document.createElement("div");
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${timeLabel}] ${message}`;
            elements["log-entries"].prepend(logEntry);
            
            // é™åˆ¶æ—¥å¿—æ•°é‡
            if (elements["log-entries"].children.length > 10) {
                elements["log-entries"].removeChild(elements["log-entries"].lastChild);
            }
        }

        // ======================
        // åˆå§‹åŒ–æ¸¸æˆ
        // ======================
        function initGame() {
            initializeMap();
            
            // è®¾ç½®æŒ‰é’®äº‹ä»¶
            document.getElementById("btn-next").addEventListener("click", nextTime);
            document.getElementById("btn-explore").addEventListener("click", explore);
            document.getElementById("btn-scavenge").addEventListener("click", scavenge);
            document.getElementById("btn-rest").addEventListener("click", rest);
            document.getElementById("btn-eat").addEventListener("click", eat);
            document.getElementById("btn-fight").addEventListener("click", fight);
            document.getElementById("btn-craft").addEventListener("click", craft);
            document.getElementById("btn-build").addEventListener("click", build);
            document.getElementById("btn-skills").addEventListener("click", showSkills);
            document.getElementById("btn-treat").addEventListener("click", treat);
            document.getElementById("btn-save").addEventListener("click", () => saveGame(1));
            document.getElementById("btn-load").addEventListener("click", openLoadModal);
            
            // å…³é—­æ¨¡æ€æ¡†æŒ‰é’®
            document.getElementById("btn-close-craft").addEventListener("click", () => {
                document.getElementById("craft-modal").style.display = "none";
            });
            
            document.getElementById("btn-close-build").addEventListener("click", () => {
                document.getElementById("build-modal").style.display = "none";
            });
            
            document.getElementById("btn-close-skills").addEventListener("click", () => {
                document.getElementById("skills-modal").style.display = "none";
            });
            
            document.getElementById("btn-close-load").addEventListener("click", () => {
                document.getElementById("load-modal").style.display = "none";
            });
            
            // æ ‡ç­¾é¡µåˆ‡æ¢
            document.querySelectorAll(".tab").forEach(tab => {
                tab.addEventListener("click", function() {
                    // ç§»é™¤æ‰€æœ‰activeç±»
                    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
                    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
                    
                    // æ·»åŠ activeç±»åˆ°å½“å‰æ ‡ç­¾
                    this.classList.add("active");
                    const tabId = `tab-${this.dataset.tab}`;
                    document.getElementById(tabId).classList.add("active");
                });
            });
            
            // æ‰€æœ‰æŒ‰é’®ç‚¹å‡»æ•ˆæœ
            document.querySelectorAll(".btn").forEach(btn => {
                btn.addEventListener("click", function() {
                    // æ·»åŠ ç‚¹å‡»ç‰¹æ•ˆ
                    this.style.boxShadow = "0 0 10px var(--primary-color)";
                    setTimeout(() => {
                        this.style.boxShadow = "none";
                    }, 200);
                });
            });
            
            updateUI();
            addLog("æ¸¸æˆå¼€å§‹ï¼ŒåŠªåŠ›åœ¨ä¸§å°¸æœ«æ—¥ä¸­ç”Ÿå­˜ä¸‹å»ï¼", "info");
            addLog("å¤©ç©ºä¸­é—ªçƒç€ä¸å¯»å¸¸çš„æ˜Ÿå…‰...", "star");
        }

        // å¯åŠ¨æ¸¸æˆ
        window.onload = initGame;
        
        // å…¨å±€å‡½æ•°
        window.craftItem = craftItem;
        window.upgradeFacility = upgradeFacility;
        window.learnSkill = learnSkill;
        window.travel = travel;
        window.loadGame = loadGame;
    </script>
</body>
</html>
